Introducing ZephJS

An introduction to the ZephJS library. ZephJS is an extremely easy to use, simple to understand, ultra-light framework for defining and using Web Components. ZephJS is perfect for people writing component libraries, teams building applications or sites that just require a few custom components, or projects building whole applications that do not want the gigantic weight of a modern JavaScript browser framework. ZephJS simplifies the process of defining custom Web Components into a highly readable declarative structure that uses standard JavaScript, standard HTML markup, and standard CSS styling. And ZephJS weighs in at less than 20k minified!

-----------------------

INTRO

Hello everyone,

I'm Glen
I'm here to tell you about
what may be the single greatest achievement
in Web Browser Technology.
Ever.

EVER.

It's called ZephJS
and it's going to change your life.

[ZephJS Logo Slide]

But, before I can tell you about ZephJS,
I need to tell you about Web Components.

[Web Components Logo]

And I know that a few months ago,
We had Shane come up here
and talk about writing web components.
So instead of giving you all that again.
I'm going to summarize exactly what he said
In two short bullet points...

1). Web Components are AWESOME.

[AWESOME slide]

2). Glen is an incredibly handsome man.

[Brian Poeshn Slide]

Not sure why he said that last bit
but it is absolutely what happened.

[pause]

Seriously though,

[Web Component Standards]

Shane told us all about
how Web Components are
a collection of Browser API standards
that make writing
custom HTML tags possible.

[my awesome button slide]

This means if I want to create <my-awesome-button>
it is possible with web components.

As Shane showed us
A Web Component,

[Custom Elements API Slide]
uses the Custom Elements API
to register a Component Class
That will be instantiated whenever
the given tag name is used.

[ShadowDOM slide]
When the Component class
is instantiated
We attach a ShadowDOM root to it
which allows us to insert
content and style
into the element
that is isolated
from the rest of the DOM.

[Web Component graphic slide]

This provides us with
a customized
encapsulated
HTML element
for use anywhere in our web document.

[Complex Web Component Example]

Any time you can envision
a custom
repeatable
display and behavior
for a web page
you should be reaching
for a web component.

This includes when you build
a complex web application
out of a collection of nested web components
or whether you just want
to offer a feature that
HTML does not currently have.

[Picture of Shane?]

Now,
Like I said,
Shane already covered how to use
the defined web component standards
and did a great job of that

[X'd Out Picture of Shane]

but honestly,
you need to forget a lot of what he said.

[Low Level Diagram]

The author's of the web component standards
never really intended for everyone
to have to understand how ShadowDOM works
or how CSS flows into or out of a Web Component.

[ Higher Order Diagram]

Instead, the goal of Web Components
was to provide a set of low-level APIs
that libraries,
could wrap up into a
higher order system.

And that's where ZephJS fits in

[ZephJS Logo]

ZephJS is a Web Component helper library,
meaning that it
Helps your write Web Components.

If you are familiar with the space,
the lit-element project
is a good comparison.

[ZephJS Blurb]

Except ZephJS isnt the same.
With ZephJS you just focus
on the component...
No need to monkey about with the ShadowDOM
or the custom elements api
Or render templates
or virtual DOMs
or any of the hundereds of things
modern frameworks saddle us with.

[Example ZephJS Component]

With ZephJS
You just write your component
with declarative syntax
using standard HTML,
standard CSS,
and standard JavaScript.
Nothing Fancy.

ZephJS provides everything a developer needs
to define a web component
in simple,
readable language
with almost no overhead.
At last look,
ZephJS minified
was less than 21k.

[pause]

So let us look at how ZephJS works...

[Example ZephJS Component - Define highlighted]

at the heart of ZephJS is the
`ZephComponents.define()` method.

To this you provide two things:

[Example ZephJS Component - Name Highlighted]

The tag name if the component you wish to define

The tag name must be
- at least three characters long
- and must have at least one dash character in it.
Otherwise call it whatever you want.

[Example ZephJS Component - Definition Highlighted]

and a definition function in which you describe the component.

The definition function
is a standard javascript function
(or arrow function)
in which you call one or more definition methods.

[Example ZephJS Component - Definition METHODS Highlighted]

Definition methods describe various aspects of your component.
For example, the `html()` definition method describes
the internal HTML of the component.
The `attribute()` definition method describes
an attribute of the component.

There are currently eighteen different definition methods
Some of the more interesting ones are

[html()]

html()

The html() definition method
is used to indicate the internal content
of the component.

It can be a string of inline HTML
or it can be a url or relative path reference
to an external file.

[css()]

css()

the css() definition method
is used to indicate the styling
for the component and the internal content.

It can be a string of inline CSS
or it can be a url or relative path reference
to an external file.

[attribute()]

attribute()

The attribute() definition method
is used to indicate that the component has
an attribute.

[property()]

property()

The property() definition method
is used to indicate that the componnet has
a exposed javascript property.

[bind() and bindAt()]

bind()
bindAt()

ZephJS has no templating language
and no template parser
or complicated psuedo-html interpolation.

Instead, if you want some part
of an element or internal content element
to change, you have to do it yourself.

ZephJS, of course,
makes this super easy to do
with bindings.

Binding lets you identify
a source element,
a source type,
a target element,
and a target type.

When the source item of the source element changes
The changed value
is copied to the target type
on the target element.

For example you can say

if the "value" attribute
of the custom element
changes,
copy it to the content of
the second DIV tag
in the internal content

`bind("@value","div:nth-child(2)","$")`

Or

if the "value" property
of the text input field with the component
changes,
copy it to the "data-value" attribute
of the element.

`bindAt("input[type=text]",".value",".","@data-value")`

The difference between bind() and bindAt()
is that bind() assumes the source element
is the current element.
whereas bindAt()
allows you to specify the source element.

bind() is a really useful concept in ZephJS
and saves you a ton of typing.

[onEvent() and onEventAt()]

onEvent()
onEventAt()

The onEvent() and onEventAt() definition methods
are used to associate an event listener
with the element
or an element within the internal content.

onEvent() adds the listener
to the element.
It takes the eventType as the first argument
and the listener function as the second.

onEventAt() adds the listener
to some element within the internal content.
It takes a CSS Query Selector as the first argument.
the eventType as the second argument.
and the listener function as the third argument.

[pause]

[ZephJS Documentation Screenshot]

There are a few other definition methods
for doing things like
handling lifecycle events
or inheriting from another ZephJS component.
Everything is carefully enumerated
in the documentation.

[ZephJS Workflow]

So once you have defined your component,
ZephJS executes the definition function
and builds what is called a Component Context,
which describes the component completely.

It then registers the given name
with the Custom Elements API
using a custom Component Class
that when instantiated
uses the Component Context
to setup the component.

[Magic Happens Here]

That sounds really complicated,
lets just say some magic happens
and ZephJS turns your name and definition
into a registered custom element
and you are good to go.

Alright, that's all the slides, lets get into it and build something...

[Example Rating Stars Screen Shot]

For our very contrived example, let us build a Star Rating component.
You know the type of thing like on netflix.
Where you click on a star and that's how much you like
that movie or tv show or whatever.

We will keep it pretty standard.
Our <rating-stars> component
will allow the user to
rate the associated item
from 0 to 5 stars, no fractional stars allowed.
Clicking a higher star indicates a higher rating,
clicking a lower star indicates a lower rating.
We want the component to show both the number of stars
and the text of what is being rated...

[ LVIE CODING ]

So let's get at it...

SETUP

First, we setup our project
which we will call rating-stars.

`npm init`

INSTALL

Next, we install ZephJS globally.
This gives us access to
the ZephJS command line tool
which will help work with Zeph...

`npm install -g zephjs`

SCAFFOLD

Once ZephJS is installed
we can use the ZephJS CLI
(called "zeph")
to scaffold our component:

`zeph new rating-stars`

This will create
a new scaffolded version
of our rating-stars component
in the current directory.
It also will ensure
that we have ZephJS itself
and a basic index.html file.

Lets look at what was created...

 - zeph.full.js is the full
 unminified version of ZephJS,
 useful for debugging and reference.

 - zeph.min.js is the minified
 version of ZephJS,
 weighing in at under 21k.

 - index.html will be created
 if no index.html exists
 and serves as an example
 of how to include a zephjs component.

 - rating-stars.js will serve
 as our component definition.

 - rating-stars.html provides
 the HTML internal content
 of our component.

 - rating-stars.css provides
 the CSS styling
 of our component
 and the internal content.

RUN

Now that we have
our scaffolded component created,
we can go ahead and try it out.

ZephJS provides us a command
to easily serve and test our components:

`zeph serve`

This will start
a HTTP server
on port 4000,
which we can hit
in our browser
to take a look at our page.

Currently
there is nothing to actually look at
on the page,
but with our inspector
we can see our <rating-stars> element
and its internal content and styles.

EDIT INDEX.HTML

So lets go add something to see.

First, we are going to build
out our index.html.
Let us say we are going to rate
the characters from Bob's Burgers:

Bob Belcher
Linda Belcher
Tina Belcher
Gene Belcher
Louise Belcher

So let us build out our index HTML
to allow each to be rated
and add a basic heading.

Each of our rating-stars elements
is going to have a separate label and value.
The value will indicate a positive whole number
from 0 to 5
to indicate what the rating currently is.
We will also leave a few values
off entirely to show how default values work

RUN

Once added,
we can refresh our page and see,
well nothing,
because our rating-stars component has no content,
but if we use the inspector
we can see the html
for each of our rating-stars
and make sure all is well.

EDIT RATING-STARS.JS

Let us define some basics
of our component
so we can start seeing something.

Our rating-stars.js file
is where we define our component,
so let us start there.

By default rating-stars.js
contains two definition methods:
html() and css().

The html() call tells
us where we get our components
internal content from.

The css() call tells
us where we get the styling information
for our component.

Both of these calls
are provided by our scaffolding
and can of course be removed or changed.
While you can provide
the HTML or CSS directly in these calls,
ZephJS, however,
recommends using external files
for HTML and CSS
just to separate everything cleanly.

In addition we to html() and css()
we also want to define a couple of attributes
on our rating-stars component:
label and value.

We do this with the attrbiute()
definition method,
which we will add now...

```
attribute("label","");
attribute("value","0");
```

Our attribute calls
tell our component
that it has the given attributes
with the default values.
If the attribute
is not provided by the usage of our component,
the default value is inserted.

EDIT RATING-STARS.HTML

Next, we want to add some internal content
to our component,
so let us edit rating-stars.html.
In here we define the HTML
that makes up the inner working
of our component.

In our case
we want to define a place for our stars,
and a place for our label.

```
<div class="stars">
</div>
<div class="label">
</div>
```

RUN

If we save now
and refresh our browser,
well, we get nothing still.
That's because although we defined our HTML,
we did not actually add any content,
just markup tags.

However, if we look with the inspector
we can see that the internal HTML
of each element is now populated.

EDIT RATING-STARS.JS

So let us add some content
to our components
so we can start seeing something.

In the case of our example,
we want to take
the VALUE of our label ATTRIBUTE
and show it
as the content of our .label DIV.

This presents us with a chance to use a binding.
As discussed before a binding
is use to propagate some value
from one part of our custom element
or internal content of our custom element.
to another part of our custom element
or internal content of our custom element.

So let us add a binding:

```
bind("@label",".label","$");
```

RUN

Now if we refresh
We have labels..

We can also show here
that if we go in with the inspector
and change the "label" attribute
the change is propagated
to the .label DIV element.

bindings are awesome!

STARS

Next, we want to add some stars.
In the interest of saving time
let me just copy the image files
from somewhere else.

copy ../example/*.png

The gave us an empty star image
and a filled star image.

Over in our rating-stars.html file
we need to add IMG tags for each.

```
<div class="star">
	<img class="filled" />
	<img class="empty" />
</div>
<div class="star">
	<img class="filled" />
	<img class="empty" />
</div>
<div class="star">
	<img class="filled" />
	<img class="empty" />
</div>
<div class="star">
	<img class="filled" />
	<img class="empty" />
</div>
<div class="star">
	<img class="filled" />
	<img class="empty" />
</div>
```

If you are paying attention
you will notice
that we did not include
a SRC attribute in our IMG tags.

This is because
I am going to show off
another feature of ZephJS.

One of the definition methods
I skipped mentioning
is the asset() method.

asset() lets you associate
an element with some external content.

ZephJS will load the asset
and replace the SRC attribute
of the associated element with
the asset data.

So let's add an asset call:

```
asset(".stars > .star > .filled","./rating-stars.filled.png")
asset(".stars > .star > .empty","./rating-stars.empty.png")
```

Something to notice here:

Although we actually have
ten IMG tags in our HTML
I only added two asset calls
one for each type (emtpy or filled).
This is because
if when matching an CSS Query Selector
such as the first argument of asset()
if this produces multiple hits,
each hit is used.
This is applies to asset()
but also to bind() / bindAt()
and onEvent() / onEventAt()

RUN

A quick refresh
and we now have stars.

But of course,
we have too many stars.

So let us go add some
CSS to make all this
look correctly.

EDIT RATING-STARS.CSS

Instead of typing all this CSS in
I'm just going to cut and paste it
to save some time.

The fundamental idea
is to layout the component
and hide the empty stars
when filled
and the filled stars
when empty.

You will notice that the CSS
we use make usage
of the :host psuedo-selector.

The :host psuedo-selector allows CSS
to target the hosting custom element
Otherwise the CSS only
applies to the internal content.

And this is one of the great things
about web components.
none of the CSS we use
will leak out of the web component.
So our component
can use really simple class name
and selectors
without any concern of affecting
any external elements.

RUN

A quick refresh
and now we have stars.

Our final piece of the puzzle,
we need the stars
to react to click events.
So if I click star
number 2,
the rating value
gets changed to 2,
and everything updates.

EDIT RATING-STARS.JS

So back to rating-stars.js
We are going to add
an event handler.

We want to handle
The click event
on each star.

To do so we are going to use
our onEventAt()
definition method.

onEventAt lets us target a specific
internal content element
and listen for a specific eventType,
in this case the "click" event.

When the click event happens,
the listener will execute.

The listener gets four arguments:
 - The event itself
 - The element the event occured on ("the selected element")
 - The custom element itself
 - And the DocumentFragment of the internal content.

Inside our listener
we can compute which star
number is being clicked
with a little simple DOM
magic.

Once we know the value,
we simply update the value attribute
and our CSS takes care of the rest.

BUNDLE

One last feature
I'd like to mention
before wrapping up
Is bundling.

Web Components are onlyreally useful
if they can be distributed.

So ZephJS provides a means
to bundle your component
into a single file.

The bundler,
which is based on Rollup,
Will traverse your definitions
find any html() or css() calls
and inline the content.
Any asset() calls are
also inlined.
Finally the bundler
wraps it all together with
a fresh minmized copy
of ZephJS
producing a single JS file
which contains everything
need for the component.

`zeph bundle rating-stars.js rs.js`

WRAP

[ZephJS Logo and Links]

So that is ZephJS.
I hope you all find it
as easy to use and read
as I do.

There is a ton of documentation available here.

I do have one last request
of everyone here
before we go drink beer...

[Try, Start, Tweet]

Please give ZephJS a try.
Please give ZephJS some github stars.
And please help me spread the word
by tweeting and retweeting ZephJS.

I am super excited about it
and I really want to see it
and the community around it grow.

[Free Beer]

In fact, if you come to the bar
and find me
and promise me you are going
to try, star, and tweet
about ZephJS
I will buy you a beer.

[Let's Get Pissed!]

Thanks a bunch.
Let's go get pissed.
