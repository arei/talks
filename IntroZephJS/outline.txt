Introducing to ZephJS

An introduction to the ZephJS library. ZephJS is an extremely easy to use, simple to understand, ultra-light framework for defining and using Web Components. ZephJS is perfect for people writing component libraries, teams building applications or sites that just require a few custom components, or projects building whole applications that do not want the gigantic weight of a modern JavaScript browser framework. ZephJS simplifies the process of defining custom Web Components into a highly readable declarative structure that uses standard JavaScript, standard HTML markup, and standard CSS styling. And ZephJS weighs in at less than 20k minified!

-----------------------

INTRO

Hello everyone,

I'm Glen
I'm here to tell you about
what may be the single greatest achievement
in Web Browser Technology.
Ever.

EVER.

It's called ZephJS and it's going to change your life.

[ZephJS Logo Slide]

But, before I can tell you about ZephJS,
I need to tell you about Web Components.

[Web Components Logo]

And I know that a few months ago,
We had Shane come up here
and talk about writing web components.
So instead of giving you all that again.
I'm going to summarize exactly what he said.

1). Web Components are AWESOME.

[AWESOME slide]

2). Glen is an incredibly handsome man.

[Brian Poeshn Slide]

Not sure why he said that last bit
but it is absolutely what happened.

[pause]

Seriously though,

[Web Component Standards]

Web Components are
a collection of Browser API standards
that make writing
custom HTML tags possible.
This means if I want to create <my-awesome-button>
it is now possible with web components.

Specifically,
A Web Component,

[Custom Elements API Slide]
is a defined,

[ShadowDOM slide]
encapsulated,

[HTML slide]
custom HTML tag.

A web component,
done right,
behaves just like any other
HTML tag you are used to using

Any time you can envision
a custom
repeatable
display and behavior
for a web page
you should be reaching
for a web component.

This includes when you build
a complex web application
out of a collection of nested web components
or whether you just want
to offer a feature that
HTML does not currently have.

Now,
Like I said,
Shane already covered how to use
the defined web component standards
and did a great job of that
but honestly,
you need to forget a lot of that.

The author's of the web component standards
never really intended for everyone
to have to understand how ShadowDOM works
or how CSS flows into or out of a Web Component.

Instead, they goal of Web Components
was to provide a set of low-level APIs
that libraries,
Web Component Helper Libraries,
could wrap up into a
higher order system.

And that's where ZephJS fits in

ZephJS is a Web Component helper library,
meaning that it
Helps your write Web Components.

If you are familiar with the space,
polymer/lit-element are good comparisons.

Except ZephJS isnt the same.
With ZephJS you just focus
on the component...
No need to monkey about with the ShadowDOM
Or rendering templates
Or the like.
Just write your component
with declarative language
using standard HTML,
CSS,
and JavaScript.
Nothing Fancy.

And then once your component is written
use ZephJS' built in bundler
to create a shipable
definition of your component
or component library
bundled into a single file.

ZephJS provides everything a developer needs
to define and bundle a web component
in simple,
readable
langauge
with almost no overhead...
In fact, ZephJS, at last look
was less then 21k.

[pause]

So let us look at how ZephJS works...

at the heart of ZephJS is the
`ZephComponents.define()` method.

To this you provide two things:

 - The tag name if the component you wish to define
 - and a definition function in which you describe the component.

The tag name must be
 - at least three characters long
 - and must have at least one dash character in it.
 Otherwise call it whatever you want.

The definition function is a standard javascript function
(or arrow function)
in which you call one or more definition methods.
Definition methods describe various aspects of your component.
For example, the `html()` definition method describes
the internal HTML of the component.
The `attribute()` definition method describes
an attribute of the component.

There are currently 18 different definition methods
you can use to describe various aspects of your component:
Some of the more interesting ones are

html()

	The html() definition method
	is used to indicate the internal content
	of the component.

	It can be a string of inline HTML
	or it can be a url or relative path reference
	to an external file.

css()

	the css() definition method
	is used to indicate the styling
	for the component and the internal content.

	It can be a string of inline CSS
	or it can be a url or relative path reference
	to an external file.

asset()

	The asset() definition method
	is used to indicate some external
	image, audio, or video asset that
	should be associated with an element
	within the internal content.

	Using asset() is strictly optional,
	but can also be very valuable when you
	are ready to bundle your component up
	to distribute.

	When the bundler encounters an asset() call
	it will locate and read the file and
	replace the asset() call with a data: url
	containing the asset data.

	This means that the bundle contains
	not only the js/html/css needed for the component
	but it can also contain the underlying assets as well
	and distributors only have to ship the one file
	instead of the definition and the assets as separate files.

attribute()

	The attribute() definition method
	is used to indicate that the component has
	an attribute.

	Additionally attribute() can provide
	a default or initial value
	for the attribute.

	attribute() is optional,
	but will make your component more readable.

property()

	The property() definition method
	is used to indicate that the componnet has
	a exposed javascript property.

	Additionally property() can provide
	a default or initial value
	for the property.

	property() is optional,
	but will make your component more readable.

bind()

	The bind() definition method
	is used to propagate
	an attrbiute, property, or content of,
	the element
	to some other part of the element
	or internal content of the element.

	ZephJS does not support
	a render property like react or angular.
	Instead, you use bind() to propagate
	changes around the component.

	The bind() method takes three arguments:

	The source item to bind, which can be one of the following:

		An attribute (which is signaled by the first character being an @ character)

		A property (which is signaled by the first character being a . character)

		The content of the element (which is signaled by the entire item string being a $ character)

	A target CSS Query Selector of where in the internal content the propagated change should be written.

	The target item to write to, which has the same structure as the source item above:

		An attribute (which is signaled by the first character being an @ character)

		A property (which is signaled by the first character being a . character)

		The content of the element (which is signaled by the entire item string being a $ character)

bindAt()

	The bindAt() method is the same as bind()
	except the first argument is

	A source CSS Query Selector of where in the internal content to watch for changes.

onCreate()

	The onCreate() definition method
	gets a function as its only argument.
	This function is called any time
	an element is created for this component.

	The function is passed the element,
	and the DocumentFragment for the internal content
	as its first two arguments.

	onCreate() allows one to tap into
	the creation process of an element
	and do some additional work as needed.

onAdd()
onRemove()


These allow the developer of the component to tap into one or more of the lifecylce events a component goes through from initialization to creation to addition/removal/adoption to attribute/property changes.

onEvent()
onEventAt()

These definition methods allow you to bind an event handler to the component or some part of the component to be fired when the event occurs. ZephjS ensures when these events do happen, the event handler knows about the component and its content.

[pause]

Given the tag name and the definition, ZephJS executes the definition and builds what is called a Component Context, which describes the component completely. It then registers the given name with a custom Component Class that uses the context to setup the component.

That sounds really complicated, lets just say some magic happens and ZephJS turns your name and definition into a registered custom element and you are good to go.

Alright, that's all the slides, lets get into it and build something...

For our very contrived example, let us build a Star Rating component.
You know the type of thing like on netflix.
Where you click on a star and that's how much you like
that movie or tv show or whatever.

We will keep it pretty standard.
Our <rating-stars> component will allow the user to rate the associated item from 0 to 5 stars, no fractional stars allowed.
Clicking a higher star indicates a higher rating,
clicking a lower star indicates a lower rating.
We want the component to show both the number of stars
and the text of what is being rated..

So let's get at it..

DEFINITIONS

	First a couple of things to keep in mind as we move forward...

	 - When I refer to the Component or Custom Component, I am talking about the definition of the component.  A component is the definition, an element is the execution.

	 - When I refer to the Element or Custom Element, I am talking about an instance of the component, as created by using the component in the HTLM (or with document.createElement()).

	 - When I refer to the Internal Content of an Element, I am talking about all of the inner elements used in rendering the Element. Generally this is the HTML provided by an html() call which we will discuss in a minute.

	 - An attribute is an HTML attribute of the element.

	 - A property is a JavaScript property associated with the element.

	 - The Content of an element is the innerHTML body of the element.

SETUP

	Alright, lets setup our project which we will call rating-stars.

	`npm init`

INSTALL

	Next, we install ZephJS globally.  This gives us access to the ZephJS command line tool which will help work with Zeph...

	`npm install -g zephjs`

SCAFFOLD

	Once ZephJS is installed we can use the ZephJS CLI (called "zeph") to scaffold our component:

	`zeph new rating-stars`

	This will create a new scaffolded version of our rating-stars component in the current directory.  It also will ensure that we have ZephJS itself and a basic index.html file.

	Lets look at what was created...

	 - zeph.full.js is the full unminified version of ZephJS, useful for debugging and reference.

	 - zeph.min.js is the minified version of ZephJS, weighing in at under 21k.

	 - index.html will be created if no index.html exists and serves as an example of how to include a zephjs component.

	 - rating-stars.js will serve as our component definition.

	 - rating-stars.html provides the HTML internal content of our component.  In ZephJS you can provide the HTML inline in the definition or as an external file.  The external file approach is cleaner, so that is what is recommended and scaffolded by default.

	 - rating-stars.css provides the CSS styling of our component and the internal content.  In ZephJS you can provide the CSS inline in the definition or as an external file.  The external file approach is cleaner, so that is what is recommended and scaffolded by default.

RUN

	Now that we have our scaffolded component created, we can go ahead and try it out.

	ZephJS provides us a command line command to easily serve and test our components:

	`zeph serve`

	This will start a HTTP server on port 4000, which we can hit in our browser to take a look at our page.

	Currently there is nothing to actually look at on the page, but with our inspector we can see our <rating-stars> element and its internal content and styles.

EDIT INDEX.HTML

	So lets go add something to see.

	First, we are going to build out our index.html. Let us say we are going to rate the characters from Bob's Burgers:

	Bob Belcher
	Linda Belcher
	Tina Belcher
	Gene Belcher
	Louise Belcher

	So let us build out our index HTML to allow each to be rated and add a basic heading. Each of our rating-stars elements is going to have a separate label and value. The value will indicate a positive whole number from 0 to 5 to indicate what the rating currently is. We will also leave a few values off entirely to show how default values work:

RUN

	Once added, we can refresh our page and see, well nothing, because our rating-stars component has no content, but if we use the inspector we can see the html for each of our rating-stars and make sure all is well.

EDIT RATING-STARS.JS

	Let us define some basics of our component so we can start seeing something.

	In our rating-stars.js file is where we define our component, so let us start there.

	By default rating-stars.js contains two definition methods: html() and css().

	The html() call tells where to get our components internal content from.

	The css() call tells us where to get the styling information for our component.

	Both of these calls are provided by our scaffolding and can of course be removed or changed. While you can provide the HTML or CSS directly in these calls, ZephJS, however, recommends using external files from HTML and CSS just to separate the two.

	In addition we to html() and css() we also want to define a couple of attributes on our rating-stars component: label and value.  We do this with the attrbiute() definition method, which we will add now...

	```
	attribute("label","");
	attribute("value","0");
	```

	Our attribute calls tell our component that it has the given attributes with the default values. If the attribute is not provided by the usage of our component, the default value is inserted. Attribute calls are optional, since any attribute can be set on any tag without an error, but it is very helpful for readability to set them in your definition.

EDIT RATING-STARS.HTML

	Next, we want to add some internal content to our component, so let us edit rating-stars.html.  In here we define the HTML that makes up the inner working of our component.  In our case we want to define a place for our stars, and a place for our labels.

	```
	<div class="stars">
	</div>
	<div class="label">
	</div>
	```

RUN

	If we save now and refresh our browser, well, we get nothing still.  That's because although we defined our HTML, we did not actually add any content, just tags.

	However, if we look with the inspector we can see that the internal HTML of each element is now populated.

EDIT RATING-STARS.JS

	So let us add some content to our components so we can start seeing something.

	In the case of our example, we want to take the VALUE of our label ATTRIBUTE and show it as the content of our .label DIV.

	This presents use with one of the interesting challenges ZephJS overcomes: How do we propagate content from one part of a component to another?  In Angular or React one might use a template within their render field but ZephJS doesn't work like that.  Instead, Zeph uses bindings to achieve a more standards based approach to this problem.

	ZephJS has two methods bind() and bindAt() to map one part of the component to another.

		bind() is used to map an attribute, property, or the content of, the custom component itself, to some other part of the component.

		bindAt() is used to map an attribute, property, or the content of, some element within the internal content, to some other part of the component.

	For our example we need to bind() the ATTRIBUTE "label" of our element, to the content of the .label DIV tag in the internal content.

		`bind("@label","div.label","$")`

	This might look a little confusing, but once you understand the basics here it will make a lot of sense.

	bind() takes at least three arguments:

		The item to bind to which can be one of the following:

			An attribute (which is signaled by the first character being an @ sign)

			A property (which is signaled)







First, we create some content for our rating-stars.html and let our component start to take shape.
We will create a place for our label, and a place for our stars, and five stars.

Next, we need to define a little bit more about our component, so lets add our attributes to our component definition.

While we are here, lets also create our star image... In the interest of saving time I'm just going to copy it from another example:

`copy ..\..\..\..\Awesome\code\zephjs\examples\RatingStars\*.png`

We can also tell our component about these image assets with our asset() definition method. Here we assocated the .filled and .empty class with the appropraite image..

We can refresh in our browser and see our HTML updated accordingly.

And we are starting to see the shape of our component.  Let's add a little styling to make things look pretty.  We style our component in the rating-stars.css file...












USING ZEPHJS

LIVE CODING
