There has never been a better time to start using Async/Await in your code.
In this talk we will talk about why Async/Await came to exist, how it
solves every javascript problems ever, and what is keeping you from using
Async/Await in your code today.

-----------------------

[SLIDE: xyz]

All right, let's get going here.
So my name is Glen.

[SLIDE: xyz]

This isn't me.

[SLIDE: xyz]

And this isn't me.

[SLIDE: xyz]

And this...
well, this one is me.
Long story.

[SLIDE: xyz]

Here I am.

[SLIDE: xyz]

and I work for this company
The Awesome Engineering Company.
Which makes libraries and enterprise applications for scaling up with nodejs.
I'll hit you with the sales pitch in a few minutes.
But for today I'm here to talk to you about

[SLIDE: xyz]

Why Are You "Awaiting" to use Async!
(I promise that will be the last pun of the night unless Sal gets crazy again and grabs the mic)

BUT!

[SLIDE: xyz]

In order to talk to you about Async/Await
we first need to revisit the history of JavaScript.
And I'm sure many of you have heard this before,
so I will try to be quick.

[SLIDE: xyz]

1993 we get the first graphical browser NCSA Mosaic

[SLIDE: xyz]

1994 we get the first commercial browser, Mosaic Netscape 0.9

[SLIDE: xyz]

1995 Netscape realizes that HTML needs a "glue language".
They hire Brendan Eich to implement the Scheme Programming Language for their Browser.
(Yes, the initial plan was to have Scheme as the scripting language of the browser.)
But just as Eich was coming on board,

[SLIDE: xyz]

Netscape signed an agreement with Sun Microsystems,
Who invented and owned the Java Programming language
to provide Java in browsers.
And thus the dark age of web applets
was born.

[SLIDE: xyz]

But netscape still needed their "glue language".
and they wanted it to have a similar syntax to java.
And they needed it NOW.

[SLIDE: xyz]

In May of 1995 Eich writes JavaScript in 10 days.
It borrows Java's syntax.
But he also borrows some very interesting features from Scheme.

[SLIDE: xyz]

In particular, Scheme stores functions and variables
in the same reference lookup table.
Meaning a variable can be a reference to a function.
this means functions can be passed as arguments
to other functions
and called within those functions.

[SLIDE: xyz]

Thus the JavaScript Callback was born.

And its used pretty much right away in the browser
for event handling and the like.
And in 1998, we get our first AJAX/XMLHttp efforts.
And thus begins the slightly less dark age known as "Callback Hell"

[SLIDE: xyz]

Wherein one function
calls a function with a callback
	which in turn calls a function with a callback
		which in turn calls a function with a callback
			which in turn calls a function with a callback
				which in turn calls a function with a callback
					which in turn calls a function with a callback

A lot of people find this frustrating
And a bunch of these people create the notion of a Promise.

[SLIDE: xyz]

A Promise
(sometimes called a Future or Deferred in other languages)
represents an operation to be completed in the future.

Promises are callbacks taken up a notch.
But underneath a promise is just a bunch of callback magic.

[SLIDE: xyz]

2012ish We see the first Promise specifications
Promises/A (and B and C and D and eventually A+)

[SLIDE: xyz]

June 2015 Promise Formally Added to JavaScript.
And everyone can start using them!
Hooray!

And thus begins the medium gray age called Promise Purgatory(tm).

[SLIDE: xyz]

Wherein one promise
chains another promise
then another promise
then another promise
then another promise
then another promise
then another promise
then another promise

But the people who came up with Promises
knew that it wasn't really about promises.
Promises were a stepping stone.
To something better.

[SLIDE: xyz]

Async/Await
But first,

[SLIDE: xyz]

A kitten!
This is my brand new kitten Zephyr.
So cute!

And now that I've pulled you in with a kitten, my sales pitch.

[SLIDE: xyz]

So in the early part of last year
I was working for a company building a
cyber security system,
much of it written in nodejs,
and handling massive amounts of data.

Yet I felt like other people
didnt really understand the scale
nodejs could be capable of.

I kept telling people about my work
and they kept looking at me like I was crazy
for wanting to write these things in nodejs.

Most people see nodejs as a very niche thing.
For your simple API level, sure.
Maybe a command line utility here or there.
But handle massive scale?
Not with a single threaded interpreted language you wont!

So in july of last year
I gave my notice
packed up my big corner office
and started an entirely new adventure.

I started
The Awesome Engineering Company.

[SLIDE: xyz]

I did this because
I wanted to explore nodejs at scale.
I did this because
I wanted to find answers to what is possible.
and I did this because
I wanted to build these answers
and share them with the world.

In the coming months
I will be sharing some of what I have been doing and building.
And I hope that all of you will help me out.
Take my stuff for a test drive.
give me lots of feedback on what you find.
file some bugs you come across.
and share with me some of your needs that nodejs at scale can address.

[SLIDE: xyz]

Now back to
Async/Await

[SLIDE: xyz]

The purpose of Async/Await is to make javascript...
wait...
for a promise to resolve or reject.
That's it.
Nothing complicated.
But its so much more than that!

[SLIDE: xyz]

First off, using await means no more then() methods.
I've been using async/await heavily for probably 18 months now and I think I've written maybe 3 then() methods in that time.

[SLIDE: xyz]

Secondly, values returned from the promise, are just returned from the await.

[SLIDE: xyz]

Third, when a promise rejects, it just becomes a thrown error!
That you can catch!
With a try/catch block.

[SLIDE: xyz]

Fourth, async/await is fundamentally cleaner to read.

[SLIDE: xyz]

Fifth, another picture of my kitten!
How can you say no to him?

So, now that we know Async/Await is awesome,
Let take a look at how we use it.

[SLIDE: xyz]

BASIC USAGE

Here is a basic example:

Say we have a function, sleep,
which returns a promise.
that resolves after n milliseconds.

Now, say we want to print out "hello",
wait 1000ms,
and then print out "world".

[SLIDE: xyz]

With callbacks, our code would look like this:
Sleep takes two arguments,
the number of milliseconds to sleep
and the callback function to execute when done.
Our HelloWorld function,
writes out "hello",
calls sleep with 1000 and the function to run when done
which after 1000ms executes.
and writes out "world".

[SLIDE: xyz]

With promises, our code would look like this:
Sleep takes one argument,
the number of milliseconds to sleep,
and returns a promise.
The promise will resolve, after the given number of milliseconds has passed.
Our HelloWorld function,
writes out "hello",
calls sleep with 1000
and tells the returned promise what to execute next.
which after 1000ms executes.
and writes out "world".

[SLIDE: xyz]

With async/await, our code would look like this:
Sleep is the same as from the promise example.
It takes one argument,
the number of milliseconds to sleep,
and returns a promise.
The promise will resolve, after the given number of milliseconds has passed.
Our HelloWorld function,
writes out "hello",
awaits a call to sleep with 1000
sleep resolves,
the await ends,
and it writes out "world".

ASYNC KEYWORD

[SLIDE: xyz]

In our basic await example, you might have noticed a new keyword before
our HelloWorld function definition: "async".

[SLIDE: xyz]

In order to use "await" we must first tell JavaScript to expect it.
this is done at the function level
by specifying that the function is an async function.
This creates a slightly different type of function than a function definition without the async keyword.
You can see this with a quick test in nodejs.

[SLIDE: xyz]

an async function will execute like anormal function
until it hits an await statement.
At that point the async function execution will pause
until the awaited promise resolves
and then the async function execution will continue

[SLIDE: xyz]

This pause doesn't block the main javascript thread at all, so
tasks waiting in the execution stack will continue to run while paused.

once we have an async function, we can use await.

AWAIT KEYWORD

[SLIDE: xyz]

The await keyword is used to tell an async function
that it should wait for the expression that follows to resolve.

await must be followed by an expression
as in "await x" or "await x(z()+47/32)".

[SLIDE: xyz]

If the evaluated expression results in a promise,
await will pause execution
until the promise resolves or rejects
The resolved value of the promise is returned by the await expression.
If a rejection occurs, await throws the rejected value as an exception.

[SLIDE: xyz]

If the evaluated expression does not result in a promise,
a value for example,
await will wrap the value in an immediately resolving promise.
So saying this is functionally the same as saying this.

[SLIDE: xyz]

also, await can be used on the right side of a return or assignment.
whatever the promise resolves with, is what the return/assignment uses.

	let z = await square(10);
	// z = 100

	return await sqaure(4);

AWAIT GOTCHAS

Some interesting things to keep in mind though.

[SLIDE: xyz]

Generally if you await on a called function, that function should return a promise.
Otherwise, the await may not pause as expected.

HANDLING EXCEPTIONS

[SLIDE: xyz]

also, One of the awesome features of async/await is that
promise rejections are just thrown as exceptions.

This means you can use a standard try/catch block
to handle the rejection you get back from your promise!

It is worth pointing out
you should always catch your await exceptions
or you end up with the dreaded UnhandledRejection exception and warning.
Which you are almost certainly aware of if you've every used promises.
But, the good news is these are far easier to read
with async/await then just straight promises.

ITERATING ARRAYS

[SLIDE: xyz]

Also, A special case comes up with async/await and for-loops.

By and large we no longer really use for loops for iterating over arrays anymore.
Instead we use Array methods like forEach() and map() and filter() which take an iteration method.

	function square(x) {
		return x*x;
	};

	function map(a) {
		return a.map((x)=>{
			return square(x);
		});
	}

	map([0,1,2,3,4,5,6,7,8,9]);
	// returns [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 ]

[SLIDE: xyz]

However, if the iteration method needs to await things dont quite work as expected.
The map function will actually return BEFORE the await functions have resolved.

	function square(x) {
		return new Promise((resolve,reject)=>{
			setTimeout(()=>{
				resolve(x*x);
			},250);
		});
	}

	function map(a) {
		return a.map(async (x,i)=>{
			return await square(x);
		});
	}

	map([0,1,2,3,4,5,6,7,8,9]);
	// returns [ Promise { <pending> },Promise { <pending> },Promise { <pending> },Promise { <pending> },Promise { <pending> },Promise { <pending> },Promise { <pending> },Promise { <pending> },Promise { <pending> },Promise { <pending> } ]

[SLIDE: xyz]

So When await is involved in array iteration,
the trick is to return an array of promises,
and wrap that in a promise.all() call
and await on that.

	function square(x) {
		return new Promise((resolve,reject)=>{
			setTimeout(()=>{
				resolve(x*x);
			},250);
		});
	}

	function map(a) {
		return Promise.all(a.map((x,i)=>{
			return square(x);
		}));
	}

	map([0,1,2,3,4,5,6,7,8,9]);
	// returns [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 ]

BUT YOU STILL WRITE PROMISES

[SLIDE: xyz]

So that's the basics of using async/await.

The thing I love about async/await is that it makes your code much more readable.
but like callbacks before it and promises after that,
it does and it doesnt.

A key thing with async/await is that it doesnt save you from writing callbacks
in many case you still keep passing functions around.

It doesn't save you from writing promises
since you need to return a promise to await on.
So you end up writing a lot of promises, but almost no then() methods.

but what it does do is free you from
nesting callbacks and chaining promises
and lots of strung together code that is really hard to follow.
and that my friends is money in the bank.

Some last things to know before you jump into async/await...

[SLIDE: xyz]

Almost nothing in nodejs core libraries uses promises at this point.
nodejs v10 adds the fs.promises api which give us promise versions of all the fs calls.

[SLIDE: xyz]

And utils.promisify() can be used to create promise versions of many library calls.
but be careful about the number of arguments.
In many cases nodejs allows for the same call to be used with different arguments,
which can make utils.promisify() act a little wierd.

[SLIDE: xyz]

Also, previously when talking about the async keyword
I mentioned that in order to use await, it must be inside an async function.
This means that you cannot use the await keyword in your top-level code.
However, there is currently a proposal for supporting top-level await for ES2019.
and there are work arounds such as using an IIFE or the like.

[SLIDE: xyz]

All right that's it.
That's why you should be using async/await in your code.
Right now.

[SLIDE: xyz]

Async/await is supported by all the modern browsers as well as
nodejs v8 or later. There are some edge cases but hopefully
internet explorer will die a horrible death soon and we can finally move on.

[SLIDE: xyz]

So stop "Awaiting" and resolve your feelings for using async/await... before the rest of the world rejects you.
Love to Sal.

Thank you.

[SLIDE: xyz]

Kitten.

























For now you can visit us at
github.com/@awesomeeng if you want to
take an early peek at some of my work.
